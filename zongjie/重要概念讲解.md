## 重要概念讲解

### 1. 异步同步阻塞非阻塞

- **同步**
  所谓同步，就是**在发出一个功能调用时，在没有得到结果之前，该调用就不返回。** 其实绝大多数函数都是同步调用。
  但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。
  最常见的例子就是 SendMessage，该函数发送一个消息给某个窗口，在对方处理完消息之前，这个函数不返回。当对方处理完毕以后，该函数才把消息处理函数所返回的 LRESULT值返回给调用者。
- **异步**
  异步的概念和同步相对。**当一个异步过程调用发出后，调用者不能立刻得到结果，实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。**
  以 CAsycSocket类为例，当一个客户端通过调用 Connect函数发出一个连接请求后，调用者线程立刻可以向下运行。当连接真正建立起来以后，socket底层会发送一个消息通知该对象。
  这里提到执行部件和调用者通过三种途径返回结果：状态、通知和回调。可以使用哪一种依赖于执行部件的实现，除非执行部件提供多种选择，否则不受调用者控制。
  如果执行部件用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低。如果是使用通知的方式，效率则很高，因为执行部件几乎不需要做额外的操作。至于回调函数，和通知没太多区别。
- **阻塞**
  阻塞调用是指**调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。**
  有人也许会把阻塞调用和同步调用等同起来，实际上它们是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。
  例如，我们在CSocket中调用Receive函数，如果缓冲区中没有数据，这个函数就会一直等待，直到有数据才返回。而此时，当前线程还会继续处理各种各样的消息。如果主窗口和调用函数在同一个线程中，除非你在特殊的界面操作函数中调用，其实主界面还是应该可以刷新。socket接收数据的另外一个函数recv则是一个阻塞调用的例子。当socket工作在阻塞模式的时候，如果没有数据的情况下调用该函数，则当前线程就会被挂起，直到有数据为止。
- **非阻塞**
  非阻塞和阻塞的概念相对应。指**在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。**

***大白话正文\***

*同步阻塞*

放假了，老王回到了乡下，由于乡下的基础设施比较差，当他在车站候车的时候，只能一直在干等着，直到公交车的到站。 这时候对于公交车（被调用着者）来说，它是“同步“的。老王（调用者）被公交车（被调用者）“阻塞”在站台上。

*异步阻塞*

放完假了，老王回到了大城市开始上班，同样在车站候车，一样在车站干等着，但是大城市的基础设施建设得比较好，当公交车到站的时候，会有广播提示提醒乘客。 那么这时候对于公交车（被调用着者）来说，它是“异步“的，到站后会通知调用者。但是此时老王（调用者）还是被公交车（被调用者）“阻塞”在站台上。

*同步非阻塞*

过年了，老王放假回来了乡下，又要开始候车了，这时候他变聪明了，没有一直在车站上干等着，而是去找隔壁的小花叙叙旧。但是又害怕车到站了自己会错过，就只能隔一段时间过来看看车到了没。 那么这时候对于公交车（被调用着者）来说，它是“同步“的。但是此时老王（调用者）可以在候车的时候去干其他的的事情，所以他是“非阻塞”的。

*异步非阻塞*

春风吹满地，新农村建设正在火热进行中，此时的乡下，公交车里面也安装了车辆到站的提醒广播。现在老王在候车的时候，可以安心的跟小花叙旧了，当听到自己需要乘坐的车辆到站广播时，才过去车站上车。 这时候对于公交车（被调用着者）来说，它是“异步“的，到站后会广播提醒，此时老王（调用者）可以在候车的时候去干其他的的事情，所以他是“非阻塞”的

**概念总结**

同步异步（被调用者），阻塞非阻塞（调用者）他们针对的对象是不一样的。对于调用者来说是阻塞跟非阻塞，被调用者是同步跟异步。

```
同步：A调用B，只有等B有结果了才返回。
异步: A调用B，B立即返回，无须等待。当B处理完之后会通过通知或者回调函数的方式来告诉A结果。
阻塞：A调用B，A会被被挂起，一直在等待B的结果，什么事都不能干。
非阻塞：A调用B，自己用被挂起等待B的结果，可以去干其他的事情。
```

### 2. Java中相关概念

Java中的IO模型有三种：
BIO（同步阻塞IO）
NIO（同步非阻塞IO）
AIO（异步非阻塞IO）
异步阻塞的模型是不存在的。

### 3. HTTP、RPC

**HTTP**

- 应用层
- 跨防火墙，能在不同局域网之间通信

**RPC**

- 远程过程调用
- TCP通信（第四层，传输层，速度快）
- 不能跨防火墙，仅支持局域网内通信

### 4. REST和RPC

#### 4.1 概念

- **REST**

REST 是一种架构风格，指的是一组架构约束条件和原则。 满足这些约束条件和原则的应用程序或设计就是 RESTful。REST 规范把所有内容都视为资源，网络上一切皆资源。

REST并没有创造新的技术，组件或服务，只是使用Web的现有特征和能力。可以完全通过 HTTP 协议实现，使用 HTTP 协议处理数据通信。

REST 架构对资源的操作包括获取、创建、修改和删除资源的操作正好对应 HTTP 协议提供的 GET、POST、PUT 和 DELETE 方法。

HTTP 动词与 REST 风格 CRUD 对应关系：

| Method | CRUD   |
| ------ | ------ |
| POST   | Create |
| GET    | Read   |
| PUT    | Update |
| DELETE | Delete |

- **RPC**

远程方法调用，就是像调用本地方法一样调用远程方法。

RPC框架要做到的最基本的三件事：

1、服务端如何确定客户端要调用的函数
在远程调用中，客户端和服务端分别维护一个【ID->函数】的对应表， ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，附上这个ID，服务端通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。

2、如何进行序列化和反序列化
客户端和服务端交互时将参数或结果转化为字节流在网络中传输，那么数据转化为字节流的或者将字节流转换成能读取的固定格式时就需要进行序列化和反序列化，序列化和反序列化的速度也会影响远程调用的效率。

3、如何进行网络传输（选择何种网络协议）
多数RPC框架选择TCP作为传输协议，也有部分选择HTTP。如gRPC使用HTTP2。不同的协议各有利弊。TCP更加高效，而HTTP在实际应用中更加的灵活。

#### 4.2 比较

都是网络交互的协议规范，通常用于多个微服务之间的通信协议。

|          | REST | RPC          |
| -------- | ---- | ------------ |
| 通信协议 | HTTP | 一般使用 TCP |
| 灵活度   | 低   | 高           |
| 性能     | 高   | 低           |

高与低是对实现两种规范框架的相对比较，但也不是绝对的，需要根据实际情况而定。

#### 4.3 应用场景

REST 和 RPC 都常用于微服务架构中。

1、HTTP相对更规范，更标准，更通用，无论哪种语言都支持 HTTP 协议。如果你是对外开放 API，例如开放平台，外部的编程语言多种多样，你无法拒绝对每种语言的支持，现在开源中间件，基本最先支持的几个协议都包含 RESTful。

2、RPC 框架作为架构微服务化的基础组件，能大大降低架构微服务化的成本，提高调用方与服务提供方的研发效率，屏蔽跨进程调用函数（服务）的各类复杂细节。RPC 协议性能要高的多，例如 Protobuf、Thrift、Kyro等，（如果算上序列化）吞吐量大概能达到 HTTP 的二倍，响应时间也更为出色。Google、Amazon、netflix（据说很可能转向grpc），阿里，实际上内部都是采用性能更高的RPC方式，对外开放的才是 RESTful。RPC 通常基于 TCP 实现，常用框架 dubbo，netty、mina、thrift

#### 4.4 调用场景

- **REST**

严格意义上说接口很规范，操作对象即为资源，对资源的四种操作（post、get、put、delete），并且参数都放在 URL 上，但是不严格的说HTTP+json、HTTP+xml，常见的HTTP API都可以称为 Rest 接口。调用及测试都很方便。

- **RPC**

远程方法调用，就是像调用本地方法一样调用远程方法，通信协议大多采用二进制方式，调用及测试有点麻烦，但是效率是毋庸置疑的。

#### 最后建议

在多系统之间的内部调用采用RPC，对外提供的服务采用REST。

### 5. 微服务架构

第一套微服务架构解决方案：Spring Boot + Spring Cloud Netflix

第二套微服务架构解决方案：Spring Boot + Dubbo + Zookeeper

第三套微服务架构解决方案：Spring Boot + Spring Cloud Alibaba

### 6. 跨域问题

### 7. 集合问题

```
Set<String> 不允许重复
List<String> 允许重复
```

### 8. RESTful

无页面

### 9. @RequestParam,@PathVariable和@RequestBody三者区别

```
@RequestParam注解
顾名思义：获取参数，即是获取传送过来的参数；例如获取下面链接的id参数值：

//链接（注意链接格式区别）
http://localhost:8090/hello?id=2
//使用@RequestParam注解获取id
public String Demo1(@RequestParam String id){
    System.out.println("链接中请求参数的id："+id);
    return null;
}
此时@RequestParam的作用就可以获取id下来并且作为形参传给方法体里面的id

@PathVariable注解
顾名思义：路径变量，即是获取链接路径上的变量，例如获取下面链接的id：

//链接（注意比较上面一条链接）
http://localhost:8090/hello/2
//使用@PathVariable注解获取id
@RequestMapping(value = "/getBook/{id}", method = RequestMethod.GET)
public String getBook(@PathVariable Integer id) {
     try {
            system.out.println("路径上的id："+id);
        } catch (ParseException e) {
            e.printStackTrace();
    }
    return null;
}
此时@PathVariable的作用是将路径上的id获取进来传递给方法体里面的形参id，但是变量名称必须一样，比如这里：value = "/getBook/{id}"和@PathVariable Integer id；两个都要是id，如果不同则报错；

@RequestBody注解
首先说下，@RequestBody注解一般主要是用来处理content-type:"application/json charset=utf-8"或者content-type:"application/xml charset=utf-8"两种请求数据，一般是异步请求用的比较多些，例如：

//异步请求部分代码
$.ajax({
　　　　　　　　url:"/hello",
　　　　　　　　type:"POST",
　　　　　　　　data:'{"id":"123","name":"chenyc"}',
　　　　　　　　content-type:"application/json charset=utf-8",
　　　　　　　　success:function(data){
　　　　　　　　　　alert(data);
　　　　　　　　}
　　　　});
//@requestBody注解获取数据代码
@requestMapping("/hello")
　　　　public String hello(@requestBody Integer id,@requestBody String name){
　　　　　　System.out.println("id:"+id+";"+"name:"+name);
　　　　}
此时@requestBody注解就可以获取到请求中的各个参数然后赋值到相对应的方法形参上，另外，当有一个实体类User包含了id和name的元素的话，在方法里面直接可以写@requestBody User user就会自动封装好给我们使用的了，不用麻烦像这样@requestBody Integer id,@requestBody String name一个一个的封装
```

### 10.1 Session共享问题解决-hash一致性

#### 优点：

- 只需要修改nginx配置，不需要修改应用代码
- 负载均衡，只要hash属性的值分布是均匀的，多台Web-server的负载是均衡的
- 支持Web-server水平扩展（session同步法受内存限制）

#### 缺点：

- Session还是存在web-server中，所以web-server重启可能导致部分session丢失，影响业务，如部分用户需要重新登陆
- 如果web-server水平扩展，rehash后的Session重新分布，会有部分用户路由不到正确的session

### 8.2 Session共享问题解决-统一存储

#### 优点：

- 安全
- 可以水平扩展，数据库/缓存水平切分即可
- 不会有session丢失

#### 缺点：

- 增加了一次网络调用，且需要修改应用代码

### 11. 线程池

#### 11.1 七大参数

- corePoolSize:[5] 核心线程数
- maximumPoolSize:[200] 最大线程数量（控制资源）
- keepAliveTime:存活时间
- unit：时间单位
- BlockingQueue<Runnable> workQueue:阻塞队列
- threadFactory：线程的创建工厂
- handler

#### 11.2 常见线程池

- completableFuture - 异步编排